                                                                                                                                                                                                     [{"title":"world","url":"/labixiaoliu.github.io/2020/06/08/world/","content":"Worldworld"},{"title":"hello","url":"/labixiaoliu.github.io/2020/06/08/hello/","content":"HEllohello"},{"title":"note/全栈课程梳理","url":"/labixiaoliu.github.io/2020/06/07/note/全栈课程梳理/","content":"linux初探远程服务器连接常用命令学习-ubuntu查看系统信息查看linux内核版本磁盘空间查询查看权限 查询结果drwxrwxrwxd文件夹l文件rread 读wwrite 写x执行三个一组root权限 组权限 其他用户权限根目录介绍home个人目录etc软件配置文件sys系统目录usr系统可执行文件var日志文件www网站目录top命令，查看进程情况常用的文件执行命令下载解压缩文件进程查看查看进程状态密钥连接服务器修改ssh端口centos需要执行semanage命令，如果找不到这个命令，可以使用yum whatprovides semanage反查安装yum instll -y policycoreutils-python,再执行semanage  命令semanage port -l |grep ssh查看当前ssh的端口开放情况semanage port -d -t ssh_port_t -p tcp 10002 可以删除不想用来连接的端口号密钥方式远程连接服务器～/.ssh文件夹下目录执行vi config远程服务器查看是否有~/.ssh目录，没有的话新建一个复制本机的id_rsa.pub文件中的内容，黏贴到远程服务器的authorized_key中，authorized_key可以有多个复制内容本机config修改保存后ssh labixiaoliu123 直接可以连接到服务器Docker学习docker和虚拟机的差别特点文件，资源，网络隔离变更管理，日志记录写时复制docker安装-ubuntu如果安装过,删除以前安装的安装依赖使用stable安装源：安装docker-ce安装格式：举例说明：比如要安装5:18.09.1~3-0~ubuntu-xenial版本的docker的话：启动服务并测试：Docker-compose集合命令docker开始常用命令docker-compose配置docker-compose.yml,配置在随意的文件夹在该文件夹内执行命令启动dockerHub登陆，然后根据提示输入账户名密码打tagpush 推送pull 拉取NVM接口测试工具-DOCleverwebpack入门gulp入门Yeoman入门Vue学习koa框架其他git公钥生成执行命令连续三次回车，生成目录在~/.ssh，id_rsa为私钥，id_rsa.pub为公钥复制id_rsa.pub的内容到github中完成后，即可以使用git clone进行下拉代码多公钥管理存在码云或者github多个仓库，需要多公钥管理生成公钥第一次回车后，定义保存公钥的地址,这里我保存到/Users/Damon/git-key,保存后在这个目录生成2个文件github_key和github_key.pub文件，分别保存私钥和公钥，然后仔回车2次完成生成过程复制github_key.pub中的内容到github的公钥管理中修改本地~/.ssh/config文件，执行vim config备注：这里值得一提的是，如果别名这里修改了，假设为github,假设我们仓库的ssh的地址是git@github.com:labixiaolliu/testing.git，我们本地执行的是git clone git@github:labixiaolliu/testing.git，需要注意这2者的区别常用命令git remote 关联仓库单关联github*创建仓库，使用git clone命令拉取本地创建文件夹，关联远程仓库多关联git stash 缓存文件​    运用场景：在修改代码的时候，临时需要出一个版本如图，有a.txt``b.txt``c.txt  三个文件在缓存区临时需要在b.txt在原来的基础上修改提交出一个版本修改b.txt，然后执行git add ``git commit -m &quot;&quot;进行提交推出stash，如果有冲突，处理冲突其他常用命令：备注：这里的一次记录和具体的文件数量没关系，执行stash和stash -p  都是一次缓存记录​            新增的文件是不能够被stash的，如果要stash新增文件，需要先add这个文件增加跟踪，然后再git stashgit reset/git log/git reflog 回滚版本和日志列表git log/git reflog分别查看log信息​    回滚版本git log最近一条commit信息会丢失，git reflog 不会,反而会增加删除这条记录的对应记录备注：git reflog 可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）git config 配置查看全局配置配置用户名，邮箱(commit 之前必须设置)git pull/push/fetch​    背景：A,B俩个地方，分别同一个仓库，并且在这个分支上进行pull/push等操作场景一：A在master分支提交了一个common.txt,B有2个分支，master和develop，俩个分支目前保持一致B在develop分支执行 git pull origin master,发现B的develop分支下拉并且merge了仓库的master分支，B的mstaer分支没有改变git fetch第一种用法：git fetch`master分支，表示远程master有更新，拉取到FETCH_HEAD这个变量分支第二种用法：直接下拉合并git reset查看本地的版本提交信息git reflog回退到上一个版本回退到具体版本冲突处理​    本地有未提交的代码，pull的时候检测到和远程有冲突，会组织下拉需要先stash或者先本地commit，git stash后，下拉代码完成后，执行git stash apply会默认进行一次merge，产生冲突并且解决git coomit后，下拉代码完成后，自动执行merge操作，这个时候进行冲突解决其他常用命令git branchgit checkoutgit taggit resetgit rebasegit flow经典模型过于复杂，不推荐第一种,适合持续集成项目，多次提交/合并/上线，还适合多发布场景Mater开发完成到一定阶段，发布一个版本到PreProduction，PreProduction做一次merge，发布一个预发布的版本PreProduction的版本稳定后，发布一个版本到Production，PreProduction和Production做一次merge，发布一个稳定版本所有的开发工作都在Master上，PreProduction和Production只需要做一次Megre发布工作，不涉及到自身的代码开发迭代第二种，适合版本项目稳定版本从master检出，bug修复在分支在master分支打下一个分支版本前，master分支可以和之前打出的tag的版本做合并，产生新的小版本sv"}]