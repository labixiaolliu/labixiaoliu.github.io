## linux初探

### 远程服务器连接

```bash
ssh -p 27822 damom@192.168.0.1
```



### 	常用命令学习-ubuntu

- 查看系统信息

  ```bash
  lsb_release -a
  ```

- 查看linux内核版本

  ```bash
  uname -a
  ```

  

- 磁盘空间查询

  ```bash
  df        以k为单位
  df -Th    以G为单位
  ```

  

- 查看权限

  ```bash
  ls -la
  ```

   查询结果`drwxrwxrwx`

  | d   | 文件夹   |
  | --- | -------- |
  | l   | 文件     |
  | r   | read 读  |
  | w   | write 写 |
  | x   | 执行     |

  三个一组

  - root权限 
  - 组权限 
  - 其他用户权限

- 根目录介绍

  | home | 个人目录       |
  | ---- | -------------- |
  | etc  | 软件配置文件   |
  | sys  | 系统目录       |
  | usr  | 系统可执行文件 |
  | var  | 日志文件       |
  | www  | 网站目录       |

  

- top命令，查看进程情况

  ```bash
  top
  ```

- 常用的文件执行命令

  ```bash
  touch a.txt    --创建文件
  mkdir          --创建文件夹
  vi a.txt       --编辑文件
  cat a.txt      --查看文件夹
  echo '1233123' >> a.txt --把内容添加到文件末尾
  echo '123' > a.txt  --将123内容覆盖a.txt的内容
  rm a.txt        --删除文件
  rm -r textdir/  --删除文件夹
  ```

  

- 下载解压缩文件

  ```bash
  wget http://xxxx.tar.gz   下载压缩包到当前目录
  tar zxvf xxx.tar.gz  解压缩文件 z-.gz文件  x解压缩  v显示解压过程 f解压缩文件名使用归档的名字
  tar zcvf xxx.tar.gz xxx  c-压缩 将xxx文件压缩成xxx.tar.gz名字的压缩文件
  ```

  

- 进程查看

  ```bash
  ps -ef |grep docker 
  kill -9 27643  强制终止27643进程
  ```

  

- 查看进程状态

  ```bash
  service sshd status    查看sshd运行状态
  service sshd stop      关闭
  service sshd restart   重启
  ```

### 密钥连接服务器

- 修改ssh端口

  ```
  netstat -anlp |grep sshd   查看service运行端口
  vi /etc/ssh/sshd_config    修改sshd配置文件 修改port  
  service sshd restart
  ```

  *centos需要执行semanage命令，如果找不到这个命令，可以使用`yum whatprovides semanage`反查*

  *安装`yum instll -y policycoreutils-python`*,

  *再执行semanage  命令*

  *`semanage port -l |grep ssh `查看当前ssh的端口开放情况*

  *`semanage port -d -t ssh_port_t -p tcp 10002` 可以删除不想用来连接的端口号*

- 密钥方式远程连接服务器

  ```
  cd ~/.ssh
  ssh-keygen    连续回车生成密钥，如果本机存在密钥，则不需要另外生成
  ```

  ～/.ssh文件夹下目录

  ![](全栈课程梳理.assets/截屏2020-06-03下午4.32.47.png)

  执行`vi config`

  远程服务器查看是否有~/.ssh目录，没有的话新建一个

  ```
  mkdir -p ~/.ssh         创建.ssh文件夹
  vi authorized_key				创建并且修改authorized_key文件
  ```

  复制本机的id_rsa.pub文件中的内容，黏贴到远程服务器的authorized_key中，authorized_key可以有多个复制内容

  本机config修改

  ```yaml
  Host labixiaoliu123
    Port 22
    HostName 118.25.133.142
    User ubuntu
    IdentityFile ~/.ssh/id_rsa
    IdentitiesOnly yes
  ```

  保存后`ssh labixiaoliu123` 直接可以连接到服务器

  



## Docker学习

### docker和虚拟机的差别

![](全栈课程梳理.assets/截屏2020-06-03下午4.45.22.png)

*特点*

- 文件，资源，网络隔离
- 变更管理，日志记录
- 写时复制

### docker安装-ubuntu

如果安装过,删除以前安装的

```bash
sudo apt-get remove docker docker-engine docker.io containerd runc
```

安装依赖

```bash
 sudo apt-get update

 sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common
    
 添加GPG key
 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

 sudo apt-key fingerprint 0EBFCD88
```

使用`stable`安装源：

```bash
$ sudo add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"
```

安装`docker-ce`

```
$ apt-cache madison docker-ce

  docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages
  docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages
  docker-ce | 18.06.1~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages
  docker-ce | 18.06.0~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages
  ...
```

安装格式：

```
$ sudo apt-get install docker-ce=<VERSION_STRING> docker-ce-cli=<VERSION_STRING> containerd.io
```

举例说明：比如要安装`5:18.09.1~3-0~ubuntu-xenial`版本的docker的话：

```bash
$ sudo apt-get install docker-ce=18.09.1 docker-ce-cli=18.09.1 containerd.io
```

启动服务并测试：

```
$ sudo service docker start

# 查看Docker运行状态
$ sudo service docker status

$ sudo docker run hello-world
```

### Docker-compose集合命令

```bash
# 下载docker-composesudo 
curl -L "https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
# 给予执行权限
sudo chmod +x /usr/local/bin/docker-compose
# 测试命令$ 
docker-compose --version
docker-compose version 1.23.2, build 1110ad01
```

### docker开始

-  **常用命令**

  ```bash
  docker run hello-world    运行docker
  docker run --name test-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:tag    运行一个mysql的docker tag是可用版本
  docker stop test-mysql    停止docker
  docker rm hello-world     删除已经停止的docker
  docker start test-mysql   启动docker
  docker logs -f test-mysql 持续展示docker的log
  # 运行一个docker名字叫test-mysql的docker，用户名密码是root 123456  端口映射为28001
  docker run --name test-mysql -e MYSQL_ROOT_PASSWORD=123456 -d -p 28001:3306 mysql:5.7
  ```

- docker-compose
  - 配置docker-compose.yml,配置在随意的文件夹

``` yaml
version: '3'
services:
  mysql1:
    image: mysql
    environment:
    - MYSQL_ROOT_PASSWORD=123456
    ports:
    - 28001:3306
  mysql2:
    image: mysql
    environment:
    - MYSQL_ROOT_PASSWORD=123456
    ports:
    - 28002:3306
```

- 在该文件夹内执行命令启动

```bash
docker-compose up -d   #开始运行
docker-compose stop    #停止
docker-compose rm      #删除
```

### dockerHub

- 登陆，然后根据提示输入账户名密码

```bash
docker login #
```

```bash
docker images #查看本地镜像
docker ps
```

![](全栈课程梳理.assets/截屏2020-06-07下午9.06.28.png)

- 打tag

  ```bash
  docker commit 2c8e27d7bb7b star7th/showdoc:1.0    #给2c8e27d7bb7b这个打一个1.0的tag,star7th/showdoc可以设置成自己的名字
  ```

  push 推送

  ```bash
  docker push star7th/showdoc:1.0
  ```

  pull 拉取

  ```bash
  docker pull lw96/mysql5.7  #lw96/mysql5.7这个是dockerHub里面他的名称
  ```

  

## NVM





## 接口测试工具-DOClever

## webpack入门

## gulp入门

## Yeoman入门

## Vue学习

## koa框架

## 其他

## git

### **公钥生成**

- 执行命令

```bash
ssh-keygen -t rsa -b 4096 -C "779817709@qq.com" 
```

- 连续三次回车，生成目录在`~/.ssh`，id_rsa为私钥，id_rsa.pub为公钥

![](全栈课程梳理.assets/截屏2020-06-04下午12.58.38.png)

- 复制id_rsa.pub的内容到github中

  ![](全栈课程梳理.assets/截屏2020-06-04下午1.04.07.png)

- 完成后，即可以使用git clone进行下拉代码

### **多公钥管理**

存在码云或者github多个仓库，需要多公钥管理

- 生成公钥

  ``` bash
  ssh-keygen -t rsa -b 4096 -C "779817709@qq.com" 
  ```

- 第一次回车后，定义保存公钥的地址,这里我保存到`/Users/Damon/git-key`,保存后在这个目录生成2个文件`github_key   `和`github_key.pub`文件，分别保存私钥和公钥，然后仔回车2次完成生成过程

  ![](全栈课程梳理.assets/截屏2020-06-04下午1.07.59.png)

- 复制`github_key.pub`中的内容到github的公钥管理中

- 修改本地`~/.ssh/config`文件，执行`vim config`

  ``` yaml
  Host github.com                            #别名
    HostName github.com                      #主机名
    User labixiaoliu                         #github的user名
    PreferredAuthentications publickey       #采用公钥鉴权方式
    IdentityFile /Users/Damon/git-key/github_key #公钥位置，我们本地保存地址的绝对路径
  ```

  **备注**：*这里值得一提的是，如果别名这里修改了，假设为<u>github</u>,假设我们仓库的ssh的地址是git@github.com:labixiaolliu/testing.git，我们本地执行的是`git clone git@github:labixiaolliu/testing.git`，需要注意这2者的区别*

### 常用命令

![](全栈课程梳理.assets/截屏2020-06-04下午1.52.40.png)

#### git remote 关联仓库

- 单关联

  - github*创建仓库，使用`git clone`命令拉取

    ``` bash
    git clone git@github.com:labixiaolliu/testGit.git
    ```

  -  本地创建文件夹，关联远程仓库

    ``` bash
    mkdir test
    cd test
    git init     
    git remote add origin git@github.com:labixiaolliu/testGit.git  #关联远程，origin是一个别名
    git push -u origin master            #-u表示将master设置为默认分支，以后可以用git push直接推送master
    ```

- 多关联

  ``` bash
  git remote add origin git@github.com:labixiaolliu/testGit.git    #关联第一个 别名叫origin
  git remote add origin1 git@github.com:labixiaolliu/testGit.git   #关联第二个 别名叫origin1，俩个仓库地址不同，这里仅作演示
  git push origin master      #推送到第一个仓库
  git push origin1 master     #推送到第二个仓库
  ```

  

#### git stash 缓存文件

​	**运用场景**：在修改代码的时候，临时需要出一个版本

- 如图，有`a.txt``b.txt``c.txt`  三个文件在缓存区

  ![](全栈课程梳理.assets/截屏2020-06-04下午4.20.57.png)

- 临时需要在`b.txt`在原来的基础上修改提交出一个版本

  ``` bash
  git stash       #将缓存区的文件全部缓存
  git stash -p    #逐个确认是否将文件放入缓存区，y：是 n：否
  ```

- 修改`b.txt`，然后执行`git add ``git commit -m ""`进行提交

- 推出stash，如果有冲突，处理冲突

  ```bash
  git stash pop    #stash推出最近的一次，并且stash list记录清除
  git stash apply  #stash推出最近的一次，并且stash list记录保留，后续需要drop掉
  ```

**其他常用命令**：

``` bash
git stash list  #查看stash记录
git stash clear #清除所有stash记录
git stash drop stash@{0} #删除具体的stash记录，stash@{0}是具体的记录，不加参数，删除最近的一次记录
```

***备注***：这里的一次记录和具体的文件数量没关系，执行`stash`和`stash -p`  都是一次缓存记录

​			新增的文件是不能够被stash的，如果要stash新增文件，需要先add这个文件增加跟踪，然后再git stash

#### git reset/git log/git reflog 回滚版本和日志列表

- `git log`/`git reflog`分别查看log信息

  ``` bash
  git log 
  ```

  ![](全栈课程梳理.assets/截屏2020-06-04下午4.48.03.png)

```bash
git reflog
```

​	![](全栈课程梳理.assets/截屏2020-06-04下午4.49.39.png)

- 回滚版本

```bash
git reset --hard 44f2f28     # 回滚到44f2f28这个版本
```

- `git log`最近一条commit信息会丢失，`git reflog` 不会,反而会增加删除这条记录的对应记录

  ![](全栈课程梳理.assets/截屏2020-06-04下午4.54.12.png)

***备注***：git reflog 可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）

#### git config 配置

- 查看全局配置

  ``` bash
  git config --global --list  #查看所有的全局配置
  ```

- 配置用户名，邮箱(commit 之前必须设置)

  ``` bash
  git config --global user.name ""
  git config --global user.email ""
  ```

#### git pull/push/fetch

​	**背景**：A,B俩个地方，分别同一个仓库，并且在这个分支上进行`pull/push`等操作

- 场景一：A在master分支提交了一个common.txt,B有2个分支，master和develop，俩个分支目前保持一致

  ![](全栈课程梳理.assets/截屏2020-06-05上午10.34.40.png)

  **B在develop分支执行 `git pull origin master`,发现B的develop分支下拉并且merge了仓库的master分支，B的mstaer分支没有改变**

  ![](全栈课程梳理.assets/截屏2020-06-05上午10.38.46.png)

- git fetch

**第一种用法：**git fetch`master分支，表示远程master有更新，拉取到FETCH_HEAD这个变量分支

``` bash
git fetch origin master
```

![](全栈课程梳理.assets/截屏2020-06-05上午10.45.35.png)

```bash
git merge FETCH_HEAD  #合并FETCH_HEAD到当前分支
```

**第二种用法：**直接下拉合并

```bash
git fetch origin master:dev1   #将远程的master下拉下来并且合并到dev1分支上，如果没有dev1，就会新建一个dev分支
```

#### git reset

- 查看本地的版本提交信息`git reflog`

  ![](全栈课程梳理.assets/截屏2020-06-05上午11.00.43.png)

- 回退到上一个版本

  ```bash
  git reset --hard head^       #回退到上一个版本
  ```

- 回退到具体版本

  ```bash
  git reset --hard ab63626   #回退到hash值为ab63626的版本
  git reset --hard head~1    #切换到HEAD@{1}的版本
  ```

####  冲突处理

​	本地有未提交的代码，pull的时候检测到和远程有冲突，会组织下拉需要先stash或者先本地commit，

- `git stash`后，下拉代码完成后，执行`git stash apply`会默认进行一次merge，产生冲突并且解决
- `git coomit`后，下拉代码完成后，自动执行merge操作，这个时候进行冲突解决

#### 其他常用命令

- `git branch`

  ``` bash
  git branch dev   #以当前代码为基准，复制一份到新建的dev分支
  ```

- `git checkout`

  ```bash
  git checkout dev #切换到dev
  git checkout -b dev  #以当前代码为基准，复制一份到新建的dev分支，并且切换到dev分支
  git checkout -- a.txt #取消a.txt 的修改,没有--也可以，但是只能取消修改的文件，不能是新增的
  ```

- git tag

  ```bash
  git tag v1.0.0    #给当前分支当前节点打一个v1.0.0的tag，可以理解为给当时打一个快照
  git tag --list    #查看本地tag列表,也可缩略为git tag -l
  git push origin v1.0.0 #单独推送tag
  git push origin --tags #推送所有的tag列表
  git push origin master --tags   #推送分支的时候把这上面的tag列表也推送到远程
  git tag -d -v1.0.0     #删除本地的tag版本
  git push origin :refs/tags/v1.0.0 #删除远程仓库的tag
  git push origin :feature     #删除远程仓库的feature分支
  git branch -D feature         #删除本地仓库的feature分支 
  ```

- git reset

  ```bash
  git reset HEAD A.txt  #对已经git add的A文件，取消对A文件的跟踪
  git reset --hard head  #回退本次修改前,特别注意，如果有新建文件，并且没有add，这个文件会保留更改，修改的文件都会回到回退本次修改前，如果新增的文件已经add，那么新增文件会取消，修改文件都会回滚到回退本次修改前
  git rest --hard head^       #回退到上一个版本
  git reset --hard ab63626   #回退到hash值为ab63626的版本 --推荐
  git reset --hard head~1    #切换到HEAD@{1}的版本
  ```

- git rebase

  



### git flow

经典模型过于复杂，不推荐

- 第一种,适合持续集成项目，多次提交/合并/上线，还适合多发布场景

  - Mater开发完成到一定阶段，发布一个版本到PreProduction，PreProduction做一次merge，发布一个预发布的版本
  - PreProduction的版本稳定后，发布一个版本到Production，PreProduction和Production做一次merge，发布一个稳定版本
  - 所有的开发工作都在Master上，PreProduction和Production只需要做一次Megre发布工作，不涉及到自身的代码开发迭代

  <img src="全栈课程梳理.assets/截屏2020-06-05下午2.49.36.png" style="zoom:50%;" />

-  第二种，适合版本项目

  - 稳定版本从master检出，bug修复在分支
  - 在master分支打下一个分支版本前，master分支可以和之前打出的tag的版本做合并，产生新的小版本

  <img src="全栈课程梳理.assets/截屏2020-06-05下午2.59.29.png" style="zoom:50%;" />

## sv



